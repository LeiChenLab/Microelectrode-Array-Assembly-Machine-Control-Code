import serial
import threading
import tkinter as tk
from tkinter import messagebox
import cv2
import time
import serial.tools.list_ports
import keyboard  # Required for keyboard input detection

# Global serial variables for motor and relay
motor_ser = None
relay_ser = None
serial_lock = threading.Lock()
camera_running = False

# Global variable to track the first connection to the relay
first_relay_connection = True

# Command cooldown time
last_command_time = 0
command_cooldown = 0.001  # seconds

# Control settings
keyboard_control_enabled = False  # State of keyboard control mode
base_displacement = 15  # Default step size in degrees for all axes except 'r'
r_displacement = 0.25    # Default step size in degrees for 'r' axis

# Grid boundaries and resolution for each axis, allowing negative side
grid_limits = {
    'X': {'min': -30000, 'max': 30000, 'step': 15},
    'Y': {'min': -30000, 'max': 30000, 'step': 15},
    'Z': {'min': -10000, 'max': 10000, 'step': 15},
    'r': {'min': -10000, 'max': 18000, 'step': 1}
}
current_position = {'X': 0, 'Y': 0, 'Z': 0, 'r': 0}  # Initial position
origin_position = {'X': 0, 'Y': 0, 'Z': 0, 'r': 0}  # Origin position

# Axis controls (updated to use the second code's mapping)
axis_controls = {
    'w': ('X', '-'),          # X axis negative
    's': ('X', '+'),          # X axis positive
    'a': ('Y', '+'),          # Y axis positive
    'd': ('Y', '-'),          # Y axis negative
    'shift': ('Z', '+'),      # Z axis positive
    'ctrl': ('Z', '-'),       # Z axis negative (changed from 'caps lock' to 'ctrl')
    'e': ('r', '+'),          # r axis positive (rotary)
    'q': ('r', '-'),          # r axis negative (rotary)
}

def find_port(device_description):
    ports = list(serial.tools.list_ports.comports())
    for port in ports:
        if device_description in port.description:
            print(f"{device_description} detected on port {port.device}")
            return port.device
    print(f"No device with description '{device_description}' found.")
    return None

def auto_connect_ports():
    global motor_port_entry, relay_port_entry, motor_ser, relay_ser

    motor_port = find_port("USB-SERIAL CH340")
    relay_port = find_port("Arduino Uno")

    if motor_port:
        motor_port_entry.delete(0, tk.END)
        motor_port_entry.insert(0, motor_port)
        motor_ser = connect_to_device(motor_port, "Motor Controller")
    else:
        messagebox.showerror("Error", "Motor control device not found.")

    if relay_port:
        relay_port_entry.delete(0, tk.END)
        relay_port_entry.insert(0, relay_port)
        relay_ser = connect_to_device(relay_port, "Arduino Controller")
    else:
        messagebox.showerror("Error", "Relay device not found.")

def connect_to_device(port, device_name):
    try:
        ser = serial.Serial(port, 9600, timeout=2)
        print(f"Connected successfully to {device_name} on {port}")
        if device_name == "Motor Controller":
            initialize_motor_controller(ser)  # Initialize motor controller on connection
        return ser
    except serial.SerialException as e:
        print(f"Connection error for {device_name} on {port}: {e}")
        messagebox.showerror("Error", f"Failed to connect to {device_name} on {port}")
        return None
    
def initialize_motor_controller(ser):
    try:
        print("Initializing motor controller...")
        response = send_command(ser, "?R\r", "Motor Controller")
        
        if response == "?R":
            print("Motor controller initialized successfully.")
        else:
            print(f"Motor controller initialization failed. Response: {response}")
    except Exception as e:
        print(f"Error during motor controller initialization: {e}")

def send_command(ser, command, device_name):
    global last_command_time
    current_time = time.time()

    if current_time - last_command_time < command_cooldown:
        print(f"{device_name} command cooldown active. Skipping command.")
        return

    try:
        with serial_lock:
            ser.write((command + '\n').encode())
            print(f"Sent command to {device_name}: {command.strip()}")
            last_command_time = current_time  # Update last command time
            time.sleep(0.009)  # Give the device time to respond

            if ser.in_waiting > 0:
                response = ser.read(ser.in_waiting).decode().strip()
                print(f"{device_name} response: {response}")
                handle_motor_response(response)
                return response
            else:
                print(f"No response from {device_name}.")
                return None
    except serial.SerialException as e:
        print(f"Failed to send command {command.strip()} to {device_name}: {e}")
        return None

def handle_motor_response(response):
    if "ERR" in response:
        print("Error received from Motor Controller. Check motor configuration or command syntax.")
    else:
        print(f"Motor Controller response: {response}")

def convert_degrees_to_pulses(degrees):
    stepper_angle_deg = 1.8
    transmission_ratio = 180
    subdivision = 2
    rotation_pulse_equivalent = stepper_angle_deg / (transmission_ratio * subdivision)
    pulses = round(degrees / rotation_pulse_equivalent)
    print(f"Converting {degrees} degrees to {pulses} pulses.")
    return pulses

def move_linear_stage(axis, direction, displacement):
    if motor_ser is None:
        messagebox.showerror("Error", "Not connected to motor control device.")
        return

    print(f"Received axis: '{axis}', direction: '{direction}', displacement: {displacement}")

    valid_axes = ['X', 'Y', 'Z', 'r']
    if axis not in valid_axes or direction not in ['+', '-']:
        messagebox.showerror("Error", "Invalid axis or direction.")
        return

    if axis == 'r':
        displacement = convert_degrees_to_pulses(displacement)

    command = f"{axis}{direction}{int(displacement)}"
    send_command(motor_ser, command, "Motor Controller")

def continuous_motor_control():
    global keyboard_control_enabled
    while True:
        if keyboard_control_enabled:
            for key, (axis, direction) in axis_controls.items():
                if keyboard.is_pressed(key):
                    step_size = r_displacement if axis == 'r' else base_displacement

                    if keyboard.is_pressed("v"):
                        step_size *= 2

                    if keyboard.is_pressed("space"):
                        step_size /= 2

                    move_linear_stage(axis, direction, step_size)
        time.sleep(0.1)

def toggle_keyboard_control():
    global keyboard_control_enabled
    keyboard_control_enabled = not keyboard_control_enabled
    print(f"Keyboard motor control {'enabled' if keyboard_control_enabled else 'disabled'}.")

def laser_relay_on():
    if relay_ser:
        send_command(relay_ser, "Laser_Relay_On", "Relay Controller")
    else:
        messagebox.showerror("Error", "Not connected to relay device.")

def laser_relay_off():
    if relay_ser:
        send_command(relay_ser, "Laser_Relay_Off", "Relay Controller")
    else:
        messagebox.showerror("Error", "Not connected to relay device.")

def launch_gui():
    global motor_port_entry, relay_port_entry

    def move_stage():
        try:
            axis = axis_entry.get().strip()
            direction = direction_var.get()
            displacement = int(displacement_entry.get().strip())
            move_linear_stage(axis, direction, displacement)
        except ValueError as e:
            messagebox.showerror("Error", f"Invalid input: {e}")

    root = tk.Tk()
    root.title("Motor Control and Camera Feed")

    tk.Label(root, text="Motor Port:").pack()
    motor_port_entry = tk.Entry(root)
    motor_port_entry.pack()

    tk.Label(root, text="Arduino Port:").pack()
    relay_port_entry = tk.Entry(root)
    relay_port_entry.pack()

    tk.Label(root, text="Axis (X, Y, Z, r):").pack()
    axis_entry = tk.Entry(root)
    axis_entry.pack()

    direction_var = tk.StringVar(value='+')
    tk.Radiobutton(root, text='Positive (+)', variable=direction_var, value='+').pack()
    tk.Radiobutton(root, text='Negative (-)', variable=direction_var, value='-').pack()

    tk.Label(root, text="Displacement:").pack()
    displacement_entry = tk.Entry(root)
    displacement_entry.pack()

    tk.Button(root, text="Move Stage", command=move_stage).pack(pady=10)
    tk.Checkbutton(root, text="Keyboard Control", command=toggle_keyboard_control).pack(pady=5)
    tk.Button(root, text="Laser On", command=laser_relay_on).pack(pady=5)
    tk.Button(root, text="Laser Off", command=laser_relay_off).pack(pady=5)

    root.mainloop()

if __name__ == "__main__":
    threading.Thread(target=launch_gui).start()
    threading.Thread(target=continuous_motor_control).start()
    auto_connect_ports()

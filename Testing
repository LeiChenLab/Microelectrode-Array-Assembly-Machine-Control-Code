import serial
import threading
import tkinter as tk
from tkinter import messagebox
import cv2
import time
import serial.tools.list_ports
import keyboard  # Required for keyboard input detection

# Global serial variables for motor and relay
motor_ser = None
relay_ser = None
serial_lock = threading.Lock()
camera_running = False

# Command cooldown time
last_command_time = 0
command_cooldown = 0.001  # seconds

# Control settings
keyboard_control_enabled = False  # State of keyboard control mode
base_displacement = 15  # Default step size in degrees for all axes except 'r'
r_displacement = 0.25    # Default step size in degrees for 'r' axis

# Axis controls
axis_controls = {
    'w': ('X', '+'),          # X axis positive
    's': ('X', '-'),          # X axis negative
    'a': ('Y', '+'),          # Y axis positive
    'd': ('Y', '-'),          # Y axis negative
    'shift': ('Z', '+'),      # Z axis positive
    'ctrl': ('Z', '-'),       # Z axis negative (changed from 'caps lock' to 'ctrl')
    'e': ('r', '+'),          # r axis positive (rotary)
    'q': ('r', '-'),          # r axis negative (rotary)
    'r': ('T', '-'),          # T axis negative
    'f': ('T', '+')           # T axis positive
}

# Auto-detect serial port
def find_port(device_description):
    """Automatically detect a port based on the device description."""
    ports = list(serial.tools.list_ports.comports())
    for port in ports:
        if device_description in port.description:
            print(f"{device_description} detected on port {port.device}")
            return port.device
    print(f"No device with description '{device_description}' found.")
    return None

def auto_detect_ports():
    """Automatically detect and populate the COM ports for motor and relay devices."""
    global motor_port_entry, relay_port_entry
    motor_port = find_port("USB-SERIAL CH340")
    relay_port = find_port("Arduino Uno")

    if motor_port:
        motor_port_entry.delete(0, tk.END)
        motor_port_entry.insert(0, motor_port)
    else:
        messagebox.showerror("Error", "Motor control device not found.")

    if relay_port:
        relay_port_entry.delete(0, tk.END)
        relay_port_entry.insert(0, relay_port)
    else:
        messagebox.showerror("Error", "Relay device not found.")

def connect_to_device(port, device_name):
    """Connects to the specified device on a COM port and initializes the motor controller if needed."""
    try:
        ser = serial.Serial(port, 9600, timeout=2)
        print(f"Connected successfully to {device_name} on {port}")
        if device_name == "Motor Controller":
            initialize_motor_controller(ser)  # Initialize motor controller on connection
        return ser
    except serial.SerialException as e:
        print(f"Connection error for {device_name} on {port}: {e}")
        messagebox.showerror("Error", f"Failed to connect to {device_name} on {port}")
        return None

def send_command(ser, command):
    """Sends a command to the motor controller and returns the response."""
    try:
        ser.write(command.encode())
        print(f"Sent command: {command.strip()}")

        # Wait for a response
        time.sleep(2)
        response = ser.read(ser.in_waiting).decode()
        cleaned_response = response.replace('\r', '').replace('\n', '').strip()
        print(f"Raw controller response: '{response}'")
        print(f"Cleaned controller response: '{cleaned_response}'")

        return cleaned_response
    except serial.SerialException as e:
        print(f"Failed to send command {command.strip()}: {e}")
        return None

def initialize_motor_controller(ser):
    """Connects to the motor controller and initializes it."""
    try:
        # Send the initialization command and check the response
        print("Initializing motor controller...")
        response = send_command(ser, "?R\r")
        
        if response == "?ROK":
            print("Motor controller initialized successfully.")
        else:
            print(f"Motor controller initialization failed. Response: {response}")
    except Exception as e:
        print(f"Error during motor controller initialization: {e}")

def connect_to_controller(port):
    """Connects to the motor controller on the specified port and initializes it."""
    try:
        # Open the serial connection to the motor controller
        print(f"Attempting to connect to motor controller on {port}...")
        ser = serial.Serial(port, 9600, timeout=2)
        
        if ser.is_open:
            print(f"Successfully connected to motor controller on {port}")
            
            # Initialize the motor controller after connection
            initialize_motor_controller(ser)
            
            return ser
        else:
            print(f"Failed to connect to motor controller on {port}")
            return None
    except serial.SerialException as e:
        print(f"Connection error for motor controller on {port}: {e}")
        return None
    
def handle_motor_response(response):
    """Handles responses from the motor controller, including error handling."""
    if "ERR" in response:
        print("Error received from Motor Controller. Check motor configuration or command syntax.")
    else:
        print(f"Motor Controller response: {response}")

def convert_degrees_to_pulses(degrees):
    stepper_angle_deg = 1.8
    transmission_ratio = 180
    subdivision = 2
    rotation_pulse_equivalent = stepper_angle_deg / (transmission_ratio * subdivision)
    pulses = round(degrees / rotation_pulse_equivalent)
    print(f"Converting {degrees} degrees to {pulses} pulses.")
    return pulses

def move_linear_stage(axis, direction, displacement):
    """Move the motor along the specified axis with the given direction and displacement."""
    if motor_ser is None:
        messagebox.showerror("Error", "Not connected to motor control device.")
        return

    print(f"Received axis: '{axis}', direction: '{direction}', displacement: {displacement}")

    valid_axes = ['X', 'Y', 'Z', 'T', 'r']
    if axis not in valid_axes or direction not in ['+', '-']:
        messagebox.showerror("Error", "Invalid axis or direction.")
        return

    # For rotary stage, convert displacement from degrees to pulses
    if axis == 'r':
        displacement = convert_degrees_to_pulses(displacement)

    command = f"{axis}{direction}{int(displacement)}\r"
    send_command(motor_ser, command, "Motor Controller")

def stop_motor_control():
    """Stop the motor control."""
    if motor_ser:
        send_command(motor_ser, "STOP", "Motor Controller")  # Assuming 'STOP' is a valid command
    else:
        messagebox.showerror("Error", "Not connected to motor control device.")
    print("Motor control stopped.")

def continuous_motor_control():
    """Continuously check for key presses and control motor based on mapped keys if enabled."""
    global keyboard_control_enabled
    while True:
        if keyboard_control_enabled:
            for key, (axis, direction) in axis_controls.items():
                if keyboard.is_pressed(key):
                    # Determine step size, halve if space bar is pressed
                    step_size = r_displacement if axis == 'r' else base_displacement
                    if keyboard.is_pressed("space"):
                        step_size /= 2
                    move_linear_stage(axis, direction, step_size)
        time.sleep(0.1)  # Add a small delay to avoid excessive CPU usage

# Relay control functions
def laser_relay_on():
    """Turn the laser relay on."""
    if relay_ser:
        send_command(relay_ser, "Laser_Relay_On", "Relay Controller")
    else:
        messagebox.showerror("Error", "Not connected to relay device.")

def laser_relay_off():
    """Turn the laser relay off."""
    if relay_ser:
        send_command(relay_ser, "Laser_Relay_Off", "Relay Controller")
    else:
        messagebox.showerror("Error", "Not connected to relay device.")

def toggle_keyboard_control():
    """Toggle keyboard control for motor movement."""
    global keyboard_control_enabled
    keyboard_control_enabled = not keyboard_control_enabled
    status = "enabled" if keyboard_control_enabled else "disabled"
    print(f"Keyboard motor control {status}.")

def launch_gui():
    """Create and launch the main GUI."""
    global motor_port_entry, relay_port_entry

    def move_stage():
        """Move the motor stage with user inputs."""
        try:
            axis = axis_entry.get().strip()
            direction = direction_var.get()
            displacement = int(displacement_entry.get().strip())
            move_linear_stage(axis, direction, displacement)
        except ValueError as e:
            messagebox.showerror("Error", f"Invalid input: {e}")

    def connect():
        """Connect to the motor and relay devices."""
        global motor_ser, relay_ser

        motor_port = motor_port_entry.get().strip()
        relay_port = relay_port_entry.get().strip()

        motor_ser = connect_to_device(motor_port, "Motor Controller")
        relay_ser = connect_to_device(relay_port, "Relay Controller")

        # Confirm connections
        if motor_ser and relay_ser:
            global camera_running
            camera_running = True

    root = tk.Tk()
    root.title("Motor and Laser Control Interface")

    # COM Port Input for Motor Controller
    tk.Label(root, text="Motor COM Port:").pack()
    motor_port_entry = tk.Entry(root)
    motor_port_entry.pack()

    # COM Port Input for Relay Controller
    tk.Label(root, text="Relay COM Port:").pack()
    relay_port_entry = tk.Entry(root)
    relay_port_entry.pack()

    # Auto Detect Button
    tk.Button(root, text="Auto Detect", command=auto_detect_ports).pack(pady=5)

    # Connect Button
    tk.Button(root, text="Connect", command=connect).pack(pady=5)

    # Axis Input
    tk.Label(root, text="Axis (X, Y, Z, T, r):").pack()
    axis_entry = tk.Entry(root)
    axis_entry.pack()

    # Direction Input
    direction_var = tk.StringVar(value='+')
    tk.Radiobutton(root, text='Positive (+)', variable=direction_var, value='+').pack()
    tk.Radiobutton(root, text='Negative (-)', variable=direction_var, value='-').pack()

    # Displacement Input
    tk.Label(root, text="Displacement (in pulses or degrees for 'r'):").pack()
    displacement_entry = tk.Entry(root)
    displacement_entry.pack()

    # Buttons for Motor Control
    tk.Button(root, text="Move Stage", command=move_stage).pack(pady=10)
    tk.Button(root, text="Stop Motor Control", command=stop_motor_control).pack(pady=10)

    # Keyboard Control Toggle
    keyboard_control_var = tk.IntVar(value=0)
    keyboard_control_checkbox = tk.Checkbutton(root, text="Keyboard Movement Mode", variable=keyboard_control_var, command=toggle_keyboard_control)
    keyboard_control_checkbox.pack(pady=5)

    # Buttons for Laser Relay Control
    tk.Button(root, text="Laser Relay On", command=laser_relay_on).pack(pady=5)
    tk.Button(root, text="Laser Relay Off", command=laser_relay_off).pack(pady=5)

    root.mainloop()

def open_camera(camera_index):
    """Function to open a camera feed."""
    cap = cv2.VideoCapture(camera_index)
    if not cap.isOpened():
        print(f"Cannot open camera {camera_index}")
        return

    while True:
        ret, frame = cap.read()
        if not ret:
            print(f"Failed to grab frame from camera {camera_index}")
            break

        cv2.imshow(f"Camera {camera_index}", frame)

        if cv2.waitKey(1) & 0xFF == ord('q'):
            break

    cap.release()
    cv2.destroyAllWindows()

if __name__ == "__main__":
    motor_port = find_port("USB-SERIAL CH340")  # Automatically detect the motor controller port
    if motor_port:
        ser = connect_to_controller(motor_port)
        if ser:
            print("Motor controller is ready.")
            # Perform additional tasks with the motor controller
        else:
            print("Failed to initialize the motor controller.")
    else:
        print("Motor controller not found.")
    # Start the GUI in a separate thread
    threading.Thread(target=launch_gui).start()

    # Start keyboard control thread
    threading.Thread(target=continuous_motor_control).start()

    # Start camera threads
    camera_0_thread = threading.Thread(target=open_camera, args=(0,))
    camera_1_thread = threading.Thread(target=open_camera, args=(1,))
    camera_0_thread.start()
    camera_1_thread.start()

    camera_0_thread.join()
    camera_1_thread.join()
